import dayjs from 'dayjs';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';
import type {
  POItemData,
  POsPaidData,
  ProductionSchedData,
  ProductionSchedSearchFormData,
} from '../types';

export class ExcelExportService {
  /**
   * Export PO Items data to Excel file
   * @param data Array of PO Item data
   * @param filename Optional filename (defaults to generated name with timestamp)
   */
  static exportToExcel(data: POItemData[], filename?: string): void {
    try {
      // Prepare data for Excel export
      const excelData = data.map((item, index) => ({
        'Row #': index + 1,
        'PO Number': item.poNumber,
        'Item Number': item.itemNumber,
        Description: item.itemDesc,
        'Order Qty': item.orderQty,
        'Order Qty Open': item.orderQtyOpen,
        'In Transit Qty': item.intransitQty,
        'Stock Qty': item.stockQty,
        'Due Date': dayjs(item.due).format('MM/DD/YYYY'),
        Buyer: `${item.buyerFirstName} ${item.buyerLastName} (${item.buyerNum})`,
        Vendor: item.vname,
        Status: item.procStatusDesc,
        Warehouse: item.whse,
      }));

      // Create workbook and worksheet
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Set column widths for better readability
      const columnWidths = [
        { wch: 8 }, // Row #
        { wch: 15 }, // PO Number
        { wch: 12 }, // Item Number
        { wch: 25 }, // Description
        { wch: 12 }, // Order Qty
        { wch: 15 }, // Order Qty Open
        { wch: 12 }, // Release Qty
        { wch: 15 }, // Release Qty Open
        { wch: 12 }, // Due Date
        { wch: 20 }, // Buyer
        { wch: 25 }, // Vendor
        { wch: 15 }, // Status
        { wch: 25 }, // Warehouse
      ];
      worksheet['!cols'] = columnWidths;

      // Add header styling
      const headerRange = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
      for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!worksheet[cellAddress]) continue;

        worksheet[cellAddress].s = {
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          fill: { fgColor: { rgb: '366092' } },
          alignment: { horizontal: 'center', vertical: 'center' },
          border: {
            top: { style: 'thin', color: { rgb: '000000' } },
            bottom: { style: 'thin', color: { rgb: '000000' } },
            left: { style: 'thin', color: { rgb: '000000' } },
            right: { style: 'thin', color: { rgb: '000000' } },
          },
        };
      }

      // Add auto-filter to the data
      worksheet['!autofilter'] = { ref: worksheet['!ref'] || 'A1' };

      // Add borders to all data cells
      for (let row = 1; row <= headerRange.e.r; row++) {
        for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          if (!worksheet[cellAddress]) continue;

          worksheet[cellAddress].s = {
            ...worksheet[cellAddress].s,
            border: {
              top: { style: 'thin', color: { rgb: 'CCCCCC' } },
              bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
              left: { style: 'thin', color: { rgb: 'CCCCCC' } },
              right: { style: 'thin', color: { rgb: 'CCCCCC' } },
            },
          };
        }
      }

      // Add summary sheet with export metadata
      const summaryData = [
        { Field: 'Export Date', Value: dayjs().format('YYYY-MM-DD HH:mm:ss') },
        { Field: 'Total Records', Value: data.length },
        { Field: 'Export Type', Value: 'PO Items Data' },
        { Field: 'Generated By', Value: 'DOM Item Inquiry System' },
      ];

      const summarySheet = XLSX.utils.json_to_sheet(summaryData);
      summarySheet['!cols'] = [{ wch: 20 }, { wch: 30 }];
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Export Summary');

      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(workbook, worksheet, 'PO Items');

      // Generate filename if not provided
      const defaultFilename = `PO_Items_Export_${dayjs().format(
        'YYYY-MM-DD_HH-mm-ss',
      )}.xlsx`;
      const finalFilename = filename || defaultFilename;

      // Generate Excel file and trigger download
      const excelBuffer = XLSX.write(workbook, {
        bookType: 'xlsx',
        type: 'array',
        cellStyles: true,
      });

      const blob = new Blob([excelBuffer], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      });

      saveAs(blob, finalFilename);

      console.log(`✅ Excel export completed: ${finalFilename}`);
      console.log(`📊 Exported ${data.length} records`);
    } catch (error) {
      console.error('❌ Excel export failed:', error);
      throw new Error('Failed to export Excel file');
    }
  }

  /**
   * Export filtered data with search criteria information
   * @param data Array of PO Item data
   * @param searchCriteria Search criteria used for filtering
   * @param filename Optional filename
   */
  static exportWithCriteria(
    data: POItemData[],
    searchCriteria: Record<string, any>,
    filename?: string,
  ): void {
    try {
      // Create workbook
      const workbook = XLSX.utils.book_new();

      // Add search criteria sheet
      const criteriaData = Object.entries(searchCriteria)
        .filter(([_, value]) => value && value !== 'Empty')
        .map(([key, value]) => ({
          'Search Field': key,
          'Search Value': value,
        }));

      if (criteriaData.length > 0) {
        const criteriaSheet = XLSX.utils.json_to_sheet(criteriaData);
        criteriaSheet['!cols'] = [{ wch: 20 }, { wch: 30 }];
        XLSX.utils.book_append_sheet(
          workbook,
          criteriaSheet,
          'Search Criteria',
        );
      }

      // Add main data sheet
      const excelData = data.map((item, index) => ({
        'Row #': index + 1,
        'PO Number': item.poNumber,
        'Item Number': item.itemNumber,
        Description: item.itemDesc,
        'Order Qty': item.orderQty,
        'Order Qty Open': item.orderQtyOpen,
        'In Transit Qty': item.intransitQty,
        'Stock Qty': item.stockQty,
        'Due Date': dayjs(item.due).format('MM/DD/YYYY'),
        Buyer: `${item.buyerFirstName} ${item.buyerLastName} (${item.buyerNum})`,
        Vendor: item.vname,
        Status: item.procStatusDesc,
        Warehouse: item.whse,
      }));

      const dataSheet = XLSX.utils.json_to_sheet(excelData);
      dataSheet['!cols'] = [
        { wch: 8 },
        { wch: 15 },
        { wch: 12 },
        { wch: 25 },
        { wch: 12 },
        { wch: 15 },
        { wch: 12 },
        { wch: 15 },
        { wch: 12 },
        { wch: 20 },
        { wch: 25 },
        { wch: 15 },
        { wch: 25 },
      ];
      XLSX.utils.book_append_sheet(workbook, dataSheet, 'PO Items');

      // Generate filename
      const defaultFilename = `PO_Items_Filtered_${dayjs().format(
        'YYYY-MM-DD_HH-mm-ss',
      )}.xlsx`;
      const finalFilename = filename || defaultFilename;

      // Export file
      const excelBuffer = XLSX.write(workbook, {
        bookType: 'xlsx',
        type: 'array',
      });

      const blob = new Blob([excelBuffer], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      });

      saveAs(blob, finalFilename);

      console.log(`✅ Excel export with criteria completed: ${finalFilename}`);
      console.log(`📊 Exported ${data.length} records with search criteria`);
    } catch (error) {
      console.error('❌ Excel export with criteria failed:', error);
      throw new Error('Failed to export Excel file with criteria');
    }
  }

  /**
   * Export Production Schedule data to Excel file
   * @param data Array of Production Schedule data
   * @param filename Optional filename (defaults to generated name with timestamp)
   */
  static exportProductionScheduleToExcel(
    data: ProductionSchedData[],
    filename?: string,
  ): void {
    try {
      // Prepare data for Excel export
      const excelData = data.map((item, index) => ({
        'Row #': index + 1,
        'Order Number': item.orderNum,
        'Item Number': item.itemNum,
        'Item Description': item.itemDesc,
        'Item Class': item.itemClass,
        'Vendor Number': item.vendorNum,
        'Vendor Name': item.vendorName,
        Warehouse: item.whse,
        'Production Resource': item.productionResource,
        'Week Number': item.wkNum,
        'Planned Qty': item.pQty,
        'Firmed Qty': item.fQty,
        'Shipped Qty': item.sQty,
        'Replaceable Flag': item.replaceableFlag,
      }));

      // Create workbook and worksheet
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Set column widths for better readability
      const columnWidths = [
        { wch: 8 }, // Row #
        { wch: 15 }, // Item Number
        { wch: 30 }, // Item Description
        { wch: 12 }, // Vendor Number
        { wch: 25 }, // Vendor Name
        { wch: 12 }, // Warehouse
        { wch: 8 }, // DRP
        { wch: 8 }, // FC
        { wch: 20 }, // Production Resource
        { wch: 15 }, // Item Class
        { wch: 12 }, // Order Type
        { wch: 12 }, // Planned Qty
        { wch: 12 }, // Firmed Qty
        { wch: 12 }, // Shipped Qty
        { wch: 12 }, // Due Date
        { wch: 12 }, // Order Date
        { wch: 12 }, // Total Weeks
        { wch: 15 }, // Weekly Planned Total
        { wch: 15 }, // Weekly Firmed Total
        { wch: 15 }, // Weekly Shipped Total
      ];
      worksheet['!cols'] = columnWidths;

      // Add header styling
      const headerRange = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
      for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!worksheet[cellAddress]) continue;

        worksheet[cellAddress].s = {
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          fill: { fgColor: { rgb: '2E7D32' } }, // Green theme for production schedule
          alignment: { horizontal: 'center', vertical: 'center' },
          border: {
            top: { style: 'thin', color: { rgb: '000000' } },
            bottom: { style: 'thin', color: { rgb: '000000' } },
            left: { style: 'thin', color: { rgb: '000000' } },
            right: { style: 'thin', color: { rgb: '000000' } },
          },
        };
      }

      // Add auto-filter to the data
      worksheet['!autofilter'] = { ref: worksheet['!ref'] || 'A1' };

      // Add borders to all data cells
      for (let row = 1; row <= headerRange.e.r; row++) {
        for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          if (!worksheet[cellAddress]) continue;

          worksheet[cellAddress].s = {
            ...worksheet[cellAddress].s,
            border: {
              top: { style: 'thin', color: { rgb: 'CCCCCC' } },
              bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
              left: { style: 'thin', color: { rgb: 'CCCCCC' } },
              right: { style: 'thin', color: { rgb: 'CCCCCC' } },
            },
          };
        }
      }

      // Add summary sheet with export metadata
      const summaryData = [
        { Field: 'Export Date', Value: dayjs().format('YYYY-MM-DD HH:mm:ss') },
        { Field: 'Total Records', Value: data.length },
        { Field: 'Export Type', Value: 'Production Schedule Data' },
        { Field: 'Generated By', Value: 'Production Schedule Inquiry System' },
      ];

      const summarySheet = XLSX.utils.json_to_sheet(summaryData);
      summarySheet['!cols'] = [{ wch: 20 }, { wch: 30 }];
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Export Summary');

      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Production Schedule');

      // Generate filename if not provided
      const defaultFilename = `Production_Schedule_Export_${dayjs().format(
        'YYYY-MM-DD_HH-mm-ss',
      )}.xlsx`;
      const finalFilename = filename || defaultFilename;

      // Generate Excel file and trigger download
      const excelBuffer = XLSX.write(workbook, {
        bookType: 'xlsx',
        type: 'array',
        cellStyles: true,
      });

      const blob = new Blob([excelBuffer], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      });

      saveAs(blob, finalFilename);

      console.log(
        `✅ Production Schedule Excel export completed: ${finalFilename}`,
      );
      console.log(`📊 Exported ${data.length} records`);
    } catch (error) {
      console.error('❌ Production Schedule Excel export failed:', error);
      throw new Error('Failed to export Production Schedule Excel file');
    }
  }

  /**
   * Export Production Schedule data with search criteria information
   * @param data Array of Production Schedule data
   * @param searchCriteria Search criteria used for filtering
   * @param filename Optional filename
   */
  static exportProductionScheduleWithCriteria(
    data: ProductionSchedData[],
    searchCriteria: ProductionSchedSearchFormData,
    filename?: string,
  ): void {
    try {
      // Create workbook
      const workbook = XLSX.utils.book_new();

      // Add search criteria sheet
      const criteriaData = [
        { Field: 'Export Date', Value: dayjs().format('YYYY-MM-DD HH:mm:ss') },
        { Field: 'Total Records', Value: data.length },
        {
          Field: 'Export Type',
          Value: 'Production Schedule with Search Criteria',
        },
        { Field: '', Value: '' }, // Empty row
        { Field: 'SEARCH CRITERIA', Value: '' },
        {
          Field: 'Active Filter Rows',
          Value: searchCriteria.filterRows.length,
        },
        ...searchCriteria.filterRows.map((row, index) => ({
          Field: `Filter ${index + 1}`,
          Value:
            `${row.logicalOperator || ''} ${row.fieldType} ${row.comparisonOperator} "${row.filterValue}"`.trim(),
        })),
        { Field: '', Value: '' }, // Empty row
        { Field: 'ORDER TYPE FILTERS', Value: '' },
        {
          Field: 'Planned Orders',
          Value: searchCriteria.orderTypeFilters.plannedOrders ? 'Yes' : 'No',
        },
        {
          Field: 'Firmed Orders',
          Value: searchCriteria.orderTypeFilters.firmedOrders ? 'Yes' : 'No',
        },
        {
          Field: 'Shipped Orders',
          Value: searchCriteria.orderTypeFilters.shippedOrders ? 'Yes' : 'No',
        },
        { Field: '', Value: '' }, // Empty row
        { Field: 'TIME PERIOD', Value: '' },
        { Field: 'Past Weeks', Value: searchCriteria.timePeriod.pastWeeks },
        { Field: 'Future Weeks', Value: searchCriteria.timePeriod.futureWeeks },
        { Field: '', Value: '' }, // Empty row
        { Field: 'REPORT OPTIONS', Value: '' },
        { Field: 'Report By', Value: searchCriteria.reportOptions.reportBy },

        {
          Field: 'Container Direct Filter',
          Value: searchCriteria.reportOptions.containerDirectFilter
            ? 'Yes'
            : 'No',
        },
      ];

      const criteriaSheet = XLSX.utils.json_to_sheet(criteriaData);
      criteriaSheet['!cols'] = [{ wch: 25 }, { wch: 40 }];
      XLSX.utils.book_append_sheet(workbook, criteriaSheet, 'Search Criteria');

      // Export main data using the existing method
      ExcelExportService.exportProductionScheduleToExcel(data, filename);

      console.log(
        '✅ Production Schedule Excel export with criteria completed',
      );
      console.log(`📊 Exported ${data.length} records with search criteria`);
    } catch (error) {
      console.error(
        '❌ Production Schedule Excel export with criteria failed:',
        error,
      );
      throw new Error(
        'Failed to export Production Schedule Excel file with criteria',
      );
    }
  }

  /**
   * Export POs Paid data to Excel file
   * @param data Array of POs Paid data
   * @param filename Optional filename (defaults to generated name with timestamp)
   */
  static exportPOsPaidData(data: POsPaidData[], filename?: string): void {
    try {
      // Prepare data for Excel export
      const excelData = data.map((item, index) => ({
        'Row #': index + 1,
        Vendor: item.vendor,
        'Vendor Number': item.vendorNum,
        Warehouse: item.warehouse,
        'Buying Entity': item.buyingEntity,
        'PO Number': item.pomOrderNum,
        'Date Paid':
          item.paymentTerms === 'Free Of Charge FOC'
            ? 'Ineligible'
            : item.pomDatePaid
              ? dayjs(item.pomDatePaid).format('MM/DD/YYYY')
              : '',
        'Currency Code': item.currencyCode,
        'Order Amount': item.orderAmount,
        'Total Adjustments': item.totalAdjustments,
        'Total Paid': item.totalPaid,
        'PO Status': item.poStatus,
        'ETD Date': item.etdDate
          ? dayjs(item.etdDate).format('MM/DD/YYYY')
          : '',
        'ETA Date': item.etaDate
          ? dayjs(item.etaDate).format('MM/DD/YYYY')
          : '',
        'On Board Date': item.onboard
          ? dayjs(item.onboard).format('MM/DD/YYYY')
          : '',
        'Payment Terms': item.paymentTerms,
        'Pmt Approved Date': item.pmtApproveDate
          ? dayjs(item.pmtApproveDate).format('MM/DD/YYYY')
          : '',
      }));

      // Create workbook and worksheet
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Set column widths for better readability
      const columnWidths = [
        { wch: 8 }, // Row #
        { wch: 30 }, // Vendor
        { wch: 12 }, // Vendor Number
        { wch: 10 }, // Warehouse
        { wch: 12 }, // Buying Entity
        { wch: 12 }, // PO Number
        { wch: 12 }, // Date Paid
        { wch: 8 }, // Currency Code
        { wch: 15 }, // Order Amount
        { wch: 15 }, // Total Adjustments
        { wch: 15 }, // Total Paid
        { wch: 12 }, // PO Status
        { wch: 12 }, // ETD Date
        { wch: 12 }, // ETA Date
        { wch: 12 }, // On Board Date
        { wch: 15 }, // Payment Terms
        { wch: 15 }, // Pmt Approved Date
      ];

      worksheet['!cols'] = columnWidths;

      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(workbook, worksheet, 'POs Paid Inquiry');

      // Generate Excel file
      const excelBuffer = XLSX.write(workbook, {
        bookType: 'xlsx',
        type: 'array',
      });

      // Create blob and download
      const blob = new Blob([excelBuffer], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      });

      const defaultFilename = `POs_Paid_Inquiry_${dayjs().format('YYYY-MM-DD_HH-mm-ss')}.xlsx`;
      saveAs(blob, filename || defaultFilename);

      console.log(
        '✅ ExcelExportService - POs Paid data exported successfully',
      );
    } catch (error) {
      console.error(
        '❌ ExcelExportService - Error exporting POs Paid data:',
        error,
      );
      throw new Error('Failed to export POs Paid data to Excel');
    }
  }
}
